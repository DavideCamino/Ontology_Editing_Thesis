\chapter{Concetti di base}

\section*{Introduzione}
Qui illustriamo alcuni dei concetti di base che serviranno per comprendere il resto della discussione, daremo una definizione di ontologia e tesauro, descriveremo brevemente gli strumenti utilizzati e i linguaggi con cui si descrivono le basi di conoscenza che tratteremo.


\section{Basi di conoscenza}
Una base di conoscenza (Knowledge Base KB) è un insieme di affermazioni, ognuna delle quali espressa attraverso un linguaggio di rappresentazione della conoscenza. Le affermazioni esprimono concetti riguardanti il dominio di interesse.

Perché una base di conoscenza possa essere utile deve essere possibile aggiungere conoscenza (fare affermazioni) e interrogare la KB; queste operazioni possono coinvolgere meccanismi di inferenza che permettano di ricavare nuove affermazioni da quelle già note. L'inferenza sfrutta una logica formale per ricavare nuove informazioni partendo da quelle che sono già presenti nella KB.\cite{russell2010artificial}
\subsection{Ontologie}
\subsubsection{Definizione}
In accordo con una definizione ampiamente accettata \cite{hitzler2021review} un'ontologia ha lo scopo di rappresentare un vocabolario per definire i concetti di un particoare dominio di interesse condiviso, ed è costituita da definizioni di classi, relazioni, funzioni e altri oggetti utili a rappresentare la conoscenza\cite{gruber1993translation}. 

La definizione è ancora un po' vaga, più precisamente un'ontologia è una base di conoscenza che permette di descrivere concetti e relazioni tra di essi specificando questi oggetti tramite un linguaggio di rappresentazione della conoscenza basato su una logica formale.
\subsubsection{Scopo delle ontologie}
Nel contesto del web semantico\footnote{Un'estensione del World Wide Web in cui le informazioni siano comprensibili ad un automa\cite{berners2001new}} le ontologie sono il mezzo principale per condividere, integrare e scoprire dati\cite{hitzler2021review}.
\subsubsection{Manipolare ontologie}
 Dato lo scopo delle ontologie risulta essere un argomento centrale la possibilità di riutilizzare, modificare e ampliare ontologie esistenti. Spesso le basi di conoscenza sono sì strutturate, ma sono eterogenee e non permettono interoperabilità. Scopo di questo lavoro è quello di presentare degli strumenti per manipolare basi di conoscenza (ci concentriamo si tesauri e ontologie) operando in modo tale da rendere compatibili informazioni tratte da fonti differenti. 
 
 Il testo \cite{suarez2015neon} presenta una trattazione teorica approfondita sulle metodologie per sviluppare un'ontologia, in particolare il framework NeOn prevede vari scenari tipici in cui ci si può trovare quando si voglia costruire un ontologia, si fa particolare attenzione ai casi nei quali siano già presenti informazioni, ma queste vanno riorganizzate.
\subsubsection{Esempio}
Consideriamo una semplice ontologia che rappresenta persone con legami di parentela genitore-figlio; le persone hanno uno o più nomi salvat nel tag \verb|comment|. Modelliamo questa ontologia con una classe \verb|Persone| e una sottoclasse \verb|Genitori| (i cui individui sono \verb|Persone| che realizzano la relazione \verb|genitoreDi|). Creiamo la relazione \verb|genitoreDi|. Infine popoliamo l'ontologia con alcuni individui. Il risultato ottenuto con Protégé è un documento XML di questo tipo:
\addxml{persone.rdf}{lst:persone.rdf}{Code/persone.rdf}
\begin{wrapfigure}{r}{0.5\textwidth}
	\centering
	\includegraphics[width=0.5\textwidth]{Picture/persone.rdf.pdf}
	\caption{Grafo dell'ontologia persone}
\end{wrapfigure}

Per quanto non sia impossibile leggere la struttura e i dati dal listato precedente un modo naturale per rappresentare le ontologie è sotto forma di grafi. Qui vediamo il grafo\footnote{tutti i grafi presenti un questo elaborato sono stati ottenuti grazie a http://vowl.visualdataweb.org/webvowl.html} che mostra la struttura dell'ontologia e possiamo apprezzare quanto sia semplice la sua struttura rispetto a quello che avremmo potuto immaginare dal listato \ref{lst:persone.rdf}. Nel grafo non sono rappresentati gli individui, possiamo comunque leggere quanti ve ne sono per ogni classe (in questo caso un individuo di tipo \verb|Persone| e uno di tipo \verb|Genitori|)


\subsection{Tesauri}
\subsubsection{Definizione}
Nella loro accezione più generale possibile i tesauri sono risorse nelle quali termini affini sono raggruppati assieme\cite{kilgarriff2000s}. In particolare un tesauro fornisce un vocabolario preciso e controllato rispetto ad un particolare dominio di interesse.\cite{srinivasan1992thesaurus} Queste strutture possono aiutare il ricercatore a riformulare le strategie di ricerca fornendo una serie di sinonimi, contrari, definizioni e traduzioni in altre lingue del termine cercato.

Esistono diversi tipi di tesauro in base alle modalità di costruzione e fruizione \cite{kilgarriff2000s}, nel nostro caso il tesauro sarà costituito da un vocabolario tassonomico in cui le relazioni tra oggetti sono di tipo BT (broader term), cioè ogni concetto può avere un riferimento ad un concetto più generale, formando in questo modo una struttura ad albero. 
\subsubsection{Espressività}
Come si può immaginare il potere espressivo di un tesauro è inferiore a quello di un'ontologia che non pone alcun limite alle relazioni definibili tra individui. In un tesauro inoltre ogni concetto ha al più un genitore, mentre in un ontologia possiamo creare una classe che erediti le caratteristiche da più classi distinte.
\section{Strumenti di editing}

\subsection{Protégé}
Protégé\footnote{https://protege.stanford.edu/} è uno strumento per la modellazione della conoscenza molto conosciuto; è un progetto open-source sviluppato all'università di Stanford e permette la manipolazione interattiva di ontologie e KB attraverso un'interfaccia grafica e delle API java.

Le funzionalità di Protégé possono essere aumentate grazie a dei componenti plug-in il cui numero è in continua crescita. Questi plug-in offrono nuovi metodi per la gestione delle ontologie, supporto per dati multimediali, engines per il ragionamento automatico e per l'interrogazione delle basi di conoscenza\cite{sivakumar2011ontology}.
\subsubsection{Descrizione del software}
Protégé presenta un'interfaccia con numerose schede, ogni scheda permette all'utente di accedere ad una differente funzionalità del software. Le schede base consentono di aggiungere nuova conoscenza e di effettuare ricerche nella KB.

Uno degli obbiettivi fondamentali di Protégé è quello di rendere l'inserimento e la ricerca in una base di conoscenza il più semplice possibile: mentre il sistema genera uno strumento per l'acquisizione della conoscenza l'utente aggiunge informazioni riempiendo form intuitivi, selezionando elementi da delle liste e disegnando diagrammi.

Protégé permette di salvare le ontologie in numerosi formati, tra cui UML, XML, RDF e OWL.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{Picture/interface_protege.png}
	\caption{Interfaccia di Protégé}
\end{figure}
\subsection{\cduce}
\cduce è un linguaggio di programmazione funzionale, staticamente tipato e orientato allo sviluppo di applicazioni che lavorano su documenti XML\cite{cduceLanguage}, nasce con líntento di migliorare XDuce: un altro linguaggio di programmazione per il processing di file XML\cite{hosoya2003xduce}. 

XDuce permette di manipolare unicamente documenti XML, questa sua specificità mostra come la presenza di feature mirate possano aiutare e semplificare lo sviluppo di applicazioni XML sacrificando, però, la possibiltà di scrivere applicazioni complesse in cui non si facciano solo semplici trasformazioni di elementi XML.

\cduce si pone l'obbiettivo di integrare specifiche funzioni orientate alla manipolazione XML all'interno di un linguaggio potenzialmente general-porpouse. Per fare questo \cduce usa un algebra general-porpouse, con costruttori di tipo standard mantendendo l'espressività e la potenza delle espressioni regolari di XDuce attraverso l'uso di tipi ricorsivi e combinatori logici (unione, intersezione, differenza).

In \cduce è possibile creare complesse strutture dati, modellare il tipo di documenti XML, e interfacciarsi in modo relativamente semplice con altri linguaggi di programmazione\cite{benzaken2002cduce}.
\subsection{Feature}\label{fature_cduce}
Vediamo brevemente le principali feature di \cduce, non entreremo nel dettaglio essendo presente una guida dettagliata sul sito del progetto\footnote{https://www.cduce.org/}
\subsubsection{Verifica statica dei tipi}
La correttezza di tipo per ogni trasformazione definita in \cduce
\subsubsection{Pattern matching}
\label{CDucePattern}
È un'operazione fondamentale in \cduce ed ha la forma:
\begin{minted}[tabsize=2, breaklines, bgcolor=bg]{OCaml}
match e with
	| p1 -> e1
	...
	| pn -> en
\end{minted}
Si cerca di fare il match tra la valutazione di un'espressione \verb|e| e vari pattern \verb|pi|. Il primo pattern che fa il match con \verb|e| attiva la corrispondente espressione sulla destra che può usare le variabili legate dal pattern.

Il controllo statico dei tipi si assicura che il pattern matching sia esaustivo, il tipo valutato per \verb|e| deve essere sottotipo dell'unione dei tipi accettati dai pattern definiti sotto.
\subsubsection{Funzioni}
La forma generale di una funzione è
\begin{minted}[tabsize=2, breaklines, bgcolor=bg]{OCaml}
fun myfunc (t1 -> s1; ...; tn -> sn)
	| p1 -> e1
	...
	| pm -> em
\end{minted}
In cui la prima riga è l'interfaccia della funzione, il rimanente è detto corpo:
\begin{itemize}
	\item interfaccia: rappresenta il modo in cui la funzione si comporta: quando riceve un elemento di tipo \verb|ti| la funzione restituirà un elemento di tipo \verb|si|, per ogni clausola \verb|ti -> si| il sistema verifica che la funzione trasformi correttamente gli elementi;
	\item corpo della funzione: le funzioni operano per pattern matching degli argomenti: viene eseguita la prima trasformazione tale che l'argomento ricevuto come parametro faccia il match col pattern \verb|pi|. 
\end{itemize}
In \cduce è possibile definire anche applicazioni parziali(curried functions\footnote{https://en.wikipedia.org/wiki/Currying}) e funzioni di ordine superiore\footnote{https://en.wikipedia.org/wiki/Higher-order\_function}
\section{Metalinguaggi}

\subsection{OWL}

\subsection{SKOS}
